declare module "flagrate/util" {
    /**
     * Identity.
     */
    export function identity<T>(a: T): T;
    /**
     * Extend Object.
     */
    export function extendObject<T, U>(dest: T, source: U): T;
    /**
     * Placeholder.
     */
    export function emptyFunction(...args: any[]): any;
    /**
     * JSON Pointer Implementation.
     */
    export namespace jsonPointer {
        function get(object: Object, pointer: string): any;
        function set<T>(object: Object, pointer: string, value: T): T;
    }
}
declare module "flagrate/element" {
    export interface FHTMLElement extends Instance, HTMLElement {
    }
    export interface FHTMLAnchorElement extends Instance, HTMLAnchorElement {
    }
    export interface FHTMLAppletElement extends Instance, HTMLAppletElement {
    }
    export interface FHTMLAreaElement extends Instance, HTMLAreaElement {
    }
    export interface FHTMLAudioElement extends Instance, HTMLAudioElement {
    }
    export interface FHTMLBaseElement extends Instance, HTMLBaseElement {
    }
    export interface FHTMLBaseFontElement extends Instance, HTMLBaseFontElement {
    }
    export interface FHTMLBodyElement extends Instance, HTMLBodyElement {
    }
    export interface FHTMLBRElement extends Instance, HTMLBRElement {
    }
    export interface FHTMLButtonElement extends Instance, HTMLButtonElement {
    }
    export interface FHTMLCanvasElement extends Instance, HTMLCanvasElement {
    }
    export interface FHTMLTableCaptionElement extends Instance, HTMLTableCaptionElement {
    }
    export interface FHTMLTableColElement extends Instance, HTMLTableColElement {
    }
    export interface FHTMLTableColElement extends Instance, HTMLTableColElement {
    }
    export interface FHTMLDataListElement extends Instance, HTMLDataListElement {
    }
    export interface FHTMLModElement extends Instance, HTMLModElement {
    }
    export interface FHTMLDirectoryElement extends Instance, HTMLDirectoryElement {
    }
    export interface FHTMLDivElement extends Instance, HTMLDivElement {
    }
    export interface FHTMLDListElement extends Instance, HTMLDListElement {
    }
    export interface FHTMLEmbedElement extends Instance, HTMLEmbedElement {
    }
    export interface FHTMLFieldSetElement extends Instance, HTMLFieldSetElement {
    }
    export interface FHTMLFontElement extends Instance, HTMLFontElement {
    }
    export interface FHTMLFormElement extends Instance, HTMLFormElement {
    }
    export interface FHTMLFrameElement extends Instance, HTMLFrameElement {
    }
    export interface FHTMLFrameSetElement extends Instance, HTMLFrameSetElement {
    }
    export interface FHTMLHeadingElement extends Instance, HTMLHeadingElement {
    }
    export interface FHTMLHeadingElement extends Instance, HTMLHeadingElement {
    }
    export interface FHTMLHeadingElement extends Instance, HTMLHeadingElement {
    }
    export interface FHTMLHeadingElement extends Instance, HTMLHeadingElement {
    }
    export interface FHTMLHeadingElement extends Instance, HTMLHeadingElement {
    }
    export interface FHTMLHeadingElement extends Instance, HTMLHeadingElement {
    }
    export interface FHTMLHeadElement extends Instance, HTMLHeadElement {
    }
    export interface FHTMLHRElement extends Instance, HTMLHRElement {
    }
    export interface FHTMLHtmlElement extends Instance, HTMLHtmlElement {
    }
    export interface FHTMLIFrameElement extends Instance, HTMLIFrameElement {
    }
    export interface FHTMLImageElement extends Instance, HTMLImageElement {
    }
    export interface FHTMLInputElement extends Instance, HTMLInputElement {
    }
    export interface FHTMLModElement extends Instance, HTMLModElement {
    }
    export interface FHTMLLabelElement extends Instance, HTMLLabelElement {
    }
    export interface FHTMLLegendElement extends Instance, HTMLLegendElement {
    }
    export interface FHTMLLIElement extends Instance, HTMLLIElement {
    }
    export interface FHTMLLinkElement extends Instance, HTMLLinkElement {
    }
    export interface FHTMLMapElement extends Instance, HTMLMapElement {
    }
    export interface FHTMLMarqueeElement extends Instance, HTMLMarqueeElement {
    }
    export interface FHTMLMenuElement extends Instance, HTMLMenuElement {
    }
    export interface FHTMLMetaElement extends Instance, HTMLMetaElement {
    }
    export interface FHTMLObjectElement extends Instance, HTMLObjectElement {
    }
    export interface FHTMLOListElement extends Instance, HTMLOListElement {
    }
    export interface FHTMLOptGroupElement extends Instance, HTMLOptGroupElement {
    }
    export interface FHTMLOptionElement extends Instance, HTMLOptionElement {
    }
    export interface FHTMLParagraphElement extends Instance, HTMLParagraphElement {
    }
    export interface FHTMLParamElement extends Instance, HTMLParamElement {
    }
    export interface FHTMLPreElement extends Instance, HTMLPreElement {
    }
    export interface FHTMLProgressElement extends Instance, HTMLProgressElement {
    }
    export interface FHTMLQuoteElement extends Instance, HTMLQuoteElement {
    }
    export interface FHTMLScriptElement extends Instance, HTMLScriptElement {
    }
    export interface FHTMLSelectElement extends Instance, HTMLSelectElement {
    }
    export interface FHTMLSourceElement extends Instance, HTMLSourceElement {
    }
    export interface FHTMLSpanElement extends Instance, HTMLSpanElement {
    }
    export interface FHTMLStyleElement extends Instance, HTMLStyleElement {
    }
    export interface FHTMLTableElement extends Instance, HTMLTableElement {
    }
    export interface FHTMLTableSectionElement extends Instance, HTMLTableSectionElement {
    }
    export interface FHTMLTableDataCellElement extends Instance, HTMLTableDataCellElement {
    }
    export interface FHTMLTextAreaElement extends Instance, HTMLTextAreaElement {
    }
    export interface FHTMLTableSectionElement extends Instance, HTMLTableSectionElement {
    }
    export interface FHTMLTableHeaderCellElement extends Instance, HTMLTableHeaderCellElement {
    }
    export interface FHTMLTableSectionElement extends Instance, HTMLTableSectionElement {
    }
    export interface FHTMLTitleElement extends Instance, HTMLTitleElement {
    }
    export interface FHTMLTableRowElement extends Instance, HTMLTableRowElement {
    }
    export interface FHTMLTrackElement extends Instance, HTMLTrackElement {
    }
    export interface FHTMLUListElement extends Instance, HTMLUListElement {
    }
    export interface FHTMLVideoElement extends Instance, HTMLVideoElement {
    }
    export interface FHTMLUnknownElement extends Instance, HTMLUnknownElement {
    }
    export interface Class {
        new (tagName: "a", attribute?: Attribute): FHTMLAnchorElement;
        new (tagName: "abbr", attribute?: Attribute): FHTMLElement;
        new (tagName: "acronym", attribute?: Attribute): FHTMLElement;
        new (tagName: "address", attribute?: Attribute): FHTMLElement;
        new (tagName: "applet", attribute?: Attribute): FHTMLAppletElement;
        new (tagName: "area", attribute?: Attribute): FHTMLAreaElement;
        new (tagName: "audio", attribute?: Attribute): FHTMLAudioElement;
        new (tagName: "b", attribute?: Attribute): FHTMLElement;
        new (tagName: "base", attribute?: Attribute): FHTMLBaseElement;
        new (tagName: "basefont", attribute?: Attribute): FHTMLBaseFontElement;
        new (tagName: "bdo", attribute?: Attribute): FHTMLElement;
        new (tagName: "big", attribute?: Attribute): FHTMLElement;
        new (tagName: "blockquote", attribute?: Attribute): FHTMLQuoteElement;
        new (tagName: "body", attribute?: Attribute): FHTMLBodyElement;
        new (tagName: "br", attribute?: Attribute): FHTMLBRElement;
        new (tagName: "button", attribute?: Attribute): FHTMLButtonElement;
        new (tagName: "canvas", attribute?: Attribute): FHTMLCanvasElement;
        new (tagName: "caption", attribute?: Attribute): FHTMLTableCaptionElement;
        new (tagName: "center", attribute?: Attribute): FHTMLElement;
        new (tagName: "cite", attribute?: Attribute): FHTMLElement;
        new (tagName: "code", attribute?: Attribute): FHTMLElement;
        new (tagName: "col", attribute?: Attribute): FHTMLTableColElement;
        new (tagName: "colgroup", attribute?: Attribute): FHTMLTableColElement;
        new (tagName: "datalist", attribute?: Attribute): FHTMLDataListElement;
        new (tagName: "dd", attribute?: Attribute): FHTMLElement;
        new (tagName: "del", attribute?: Attribute): FHTMLModElement;
        new (tagName: "dfn", attribute?: Attribute): FHTMLElement;
        new (tagName: "dir", attribute?: Attribute): FHTMLDirectoryElement;
        new (tagName?: "div", attribute?: Attribute): FHTMLDivElement;
        new (tagName: "dl", attribute?: Attribute): FHTMLDListElement;
        new (tagName: "dt", attribute?: Attribute): FHTMLElement;
        new (tagName: "em", attribute?: Attribute): FHTMLElement;
        new (tagName: "embed", attribute?: Attribute): FHTMLEmbedElement;
        new (tagName: "fieldset", attribute?: Attribute): FHTMLFieldSetElement;
        new (tagName: "font", attribute?: Attribute): FHTMLFontElement;
        new (tagName: "form", attribute?: Attribute): FHTMLFormElement;
        new (tagName: "frame", attribute?: Attribute): FHTMLFrameElement;
        new (tagName: "frameset", attribute?: Attribute): FHTMLFrameSetElement;
        new (tagName: "h1", attribute?: Attribute): FHTMLHeadingElement;
        new (tagName: "h2", attribute?: Attribute): FHTMLHeadingElement;
        new (tagName: "h3", attribute?: Attribute): FHTMLHeadingElement;
        new (tagName: "h4", attribute?: Attribute): FHTMLHeadingElement;
        new (tagName: "h5", attribute?: Attribute): FHTMLHeadingElement;
        new (tagName: "h6", attribute?: Attribute): FHTMLHeadingElement;
        new (tagName: "head", attribute?: Attribute): FHTMLHeadElement;
        new (tagName: "hr", attribute?: Attribute): FHTMLHRElement;
        new (tagName: "html", attribute?: Attribute): FHTMLHtmlElement;
        new (tagName: "i", attribute?: Attribute): FHTMLElement;
        new (tagName: "iframe", attribute?: Attribute): FHTMLIFrameElement;
        new (tagName: "img", attribute?: Attribute): FHTMLImageElement;
        new (tagName: "input", attribute?: Attribute): FHTMLInputElement;
        new (tagName: "ins", attribute?: Attribute): FHTMLModElement;
        new (tagName: "isindex", attribute?: Attribute): FHTMLUnknownElement;
        new (tagName: "kbd", attribute?: Attribute): FHTMLElement;
        new (tagName: "keygen", attribute?: Attribute): FHTMLElement;
        new (tagName: "label", attribute?: Attribute): FHTMLLabelElement;
        new (tagName: "legend", attribute?: Attribute): FHTMLLegendElement;
        new (tagName: "li", attribute?: Attribute): FHTMLLIElement;
        new (tagName: "link", attribute?: Attribute): FHTMLLinkElement;
        new (tagName: "listing", attribute?: Attribute): FHTMLPreElement;
        new (tagName: "map", attribute?: Attribute): FHTMLMapElement;
        new (tagName: "marquee", attribute?: Attribute): FHTMLMarqueeElement;
        new (tagName: "menu", attribute?: Attribute): FHTMLMenuElement;
        new (tagName: "meta", attribute?: Attribute): FHTMLMetaElement;
        new (tagName: "nextid", attribute?: Attribute): FHTMLUnknownElement;
        new (tagName: "nobr", attribute?: Attribute): FHTMLElement;
        new (tagName: "object", attribute?: Attribute): FHTMLObjectElement;
        new (tagName: "ol", attribute?: Attribute): FHTMLOListElement;
        new (tagName: "optgroup", attribute?: Attribute): FHTMLOptGroupElement;
        new (tagName: "option", attribute?: Attribute): FHTMLOptionElement;
        new (tagName: "p", attribute?: Attribute): FHTMLParagraphElement;
        new (tagName: "param", attribute?: Attribute): FHTMLParamElement;
        new (tagName: "plaintext", attribute?: Attribute): FHTMLElement;
        new (tagName: "pre", attribute?: Attribute): FHTMLPreElement;
        new (tagName: "progress", attribute?: Attribute): FHTMLProgressElement;
        new (tagName: "q", attribute?: Attribute): FHTMLQuoteElement;
        new (tagName: "rt", attribute?: Attribute): FHTMLElement;
        new (tagName: "ruby", attribute?: Attribute): FHTMLElement;
        new (tagName: "s", attribute?: Attribute): FHTMLElement;
        new (tagName: "samp", attribute?: Attribute): FHTMLElement;
        new (tagName: "script", attribute?: Attribute): FHTMLScriptElement;
        new (tagName: "select", attribute?: Attribute): FHTMLSelectElement;
        new (tagName: "small", attribute?: Attribute): FHTMLElement;
        new (tagName: "source", attribute?: Attribute): FHTMLSourceElement;
        new (tagName: "span", attribute?: Attribute): FHTMLSpanElement;
        new (tagName: "strike", attribute?: Attribute): FHTMLElement;
        new (tagName: "strong", attribute?: Attribute): FHTMLElement;
        new (tagName: "style", attribute?: Attribute): FHTMLStyleElement;
        new (tagName: "sub", attribute?: Attribute): FHTMLElement;
        new (tagName: "sup", attribute?: Attribute): FHTMLElement;
        new (tagName: "table", attribute?: Attribute): FHTMLTableElement;
        new (tagName: "tbody", attribute?: Attribute): FHTMLTableSectionElement;
        new (tagName: "td", attribute?: Attribute): FHTMLTableDataCellElement;
        new (tagName: "textarea", attribute?: Attribute): FHTMLTextAreaElement;
        new (tagName: "tfoot", attribute?: Attribute): FHTMLTableSectionElement;
        new (tagName: "th", attribute?: Attribute): FHTMLTableHeaderCellElement;
        new (tagName: "thead", attribute?: Attribute): FHTMLTableSectionElement;
        new (tagName: "title", attribute?: Attribute): FHTMLTitleElement;
        new (tagName: "tr", attribute?: Attribute): FHTMLTableRowElement;
        new (tagName: "track", attribute?: Attribute): FHTMLTrackElement;
        new (tagName: "tt", attribute?: Attribute): FHTMLElement;
        new (tagName: "u", attribute?: Attribute): FHTMLElement;
        new (tagName: "ul", attribute?: Attribute): FHTMLUListElement;
        new (tagName: "var", attribute?: Attribute): FHTMLElement;
        new (tagName: "video", attribute?: Attribute): FHTMLVideoElement;
        new (tagName: "xmp", attribute?: Attribute): FHTMLPreElement;
        new (tagName: string, attribute?: Attribute): FHTMLElement;
        /** Tells whether `element` is visible. */
        visible<T extends Node>(element: T): boolean;
        /** Tells whether `element` is exists on document. */
        exists<T extends Node>(element: T): boolean;
        /** Toggles the visibility of `element`. */
        toggle<T extends Node>(element: T): T;
        /** Sets `display: none` on `element`. */
        hide<T extends Node>(element: T): T;
        /** Removes `display: none` on `element`. */
        show<T extends Node>(element: T): T;
        /** Completely removes `element` from the document. */
        remove<T extends Node>(element: T): void;
        /** Clear the _content_ of `element`. */
        update<T extends Node>(element: T): T;
        /** Update the _content_ of `element` with the `string` as HTML. */
        update<T extends Node>(element: T, string: string): T;
        /** **DEPRECATED**: Use updateText instead. */
        update<T extends Node>(element: T, number: number): T;
        /** Replaces the _content_ of `element` with the `newContent`. */
        update<T extends Node, U extends Node>(element: T, newContent: U): T;
        /** Update the _content_ of `element` with the `string` as Text. */
        updateText<T extends Node>(element: T, string: string | number | boolean): T;
        /** Update the _content_ of `element` with the `content` element as Text. */
        updateText<T extends Node, U extends Node>(element: T, content: U): T;
        /** Insert the `string` as HTML to the _content_ of `element`. */
        insert<T extends Node>(element: T, string: string): T;
        /** **DEPRECATED**: Use updateText instead. */
        insert<T extends Node>(element: T, number: number): T;
        /** Insert the `content` to the _content_ of `element`. */
        insert<T extends Node, U extends Node>(element: T, content: U): T;
        /** Insert the content(s) to the specific position of _content_ of `element` (Advanced).  */
        insert<T extends Node>(element: T, insertion: Insertion): T;
        /** Insert the `string` to the _content_ of `element` */
        insertText<T extends Node>(element: T, string: string | number | boolean): T;
        /** Insert the content(s) to the specific position of _content_ of `element` (Advanced). */
        insertText<T extends Node>(element: T, content: Insertion): T;
        /** Insert `element` to the _content_ of `element`. */
        insertTo<T extends Node, U extends Node>(element: T, to: U): T;
        /** Insert `element` to the specific position of _content_ of `element`. */
        insertTo<T extends Node, U extends Node>(element: T, to: U, position: InsertPosition): T;
        /** **DEPRECATED**: Use getAttribute instead. */
        readAttribute<T extends Node>(element: T, name: string): string;
        /** Set attribute `name`. */
        writeAttribute<T extends Node>(element: T, name: string): T;
        /** Set or Remove attribute `name`. */
        writeAttribute<T extends Node>(element: T, name: string, exists: boolean): T;
        /** Set value of attribute `name`. */
        writeAttribute<T extends Node>(element: T, name: string, value: string): T;
        /** Set attribute(s) by name/value pairs. */
        writeAttribute<T extends Node>(element: T, attribute: Attribute): T;
        /** Get dimenstions of `element`. */
        getDimensions<T extends Node>(element: T): Dimensions;
        /** Get height of `element`. */
        getHeight<T extends Node>(element: T): number;
        /** Get width of `element`. */
        getWidth<T extends Node>(element: T): number;
        /** Get cumulative offset of `element`. */
        cumulativeOffset<T extends Node>(element: T): Offset;
        /** Get cumulative scroll offset of `element`. */
        cumulativeScrollOffset<T extends Node>(element: T): Offset;
        /** Tells weather class name is exists. */
        hasClassName<T extends Node>(element: T, className: string): boolean;
        /** Add class name to `element`. */
        addClassName<T extends Node>(element: T, className: string): T;
        /** Remove class name from `element`. */
        removeClassName<T extends Node>(element: T, className: string): T;
        /** Toggles the class name of `element`. */
        toggleClassName<T extends Node>(element: T, className: string): T;
        /** Get value of style property of `element`. */
        getStyle<T extends Node>(element: T, propertyName: NumberProperty): number;
        /** Get value of style property of `element`. */
        getStyle<T extends Node>(element: T, propertyName: string): string;
        /** Set value of style property of `element`. */
        setStyle<T extends Node>(element: T, style: Property): T;
        /** Registers an event handler on a DOM element. */
        on<T extends Node>(element: T, eventType: string, listener: EventListener, useCapture?: boolean): T;
        /** Unregisters an event handler on a DOM element. */
        off<T extends Node>(element: T, eventType: string, listener?: EventListener, useCapture?: boolean): T;
        /** Fires a custom event. */
        fire<T extends Node>(element: T, eventType: string, property?: any): T;
        /** Emit a custom event. (alias of fire) */
        emit<T extends Node>(element: T, eventType: string, property?: any): T;
        /** Extends the given `element` instance. */
        extend<T extends Node>(element: T): FHTMLElement;
        /** Check object type. */
        isElement(object: any): boolean;
    }
    export interface createElement {
        (tagName: "a", attribute?: Attribute): FHTMLAnchorElement;
        (tagName: "abbr", attribute?: Attribute): FHTMLElement;
        (tagName: "acronym", attribute?: Attribute): FHTMLElement;
        (tagName: "address", attribute?: Attribute): FHTMLElement;
        (tagName: "applet", attribute?: Attribute): FHTMLAppletElement;
        (tagName: "area", attribute?: Attribute): FHTMLAreaElement;
        (tagName: "audio", attribute?: Attribute): FHTMLAudioElement;
        (tagName: "b", attribute?: Attribute): FHTMLElement;
        (tagName: "base", attribute?: Attribute): FHTMLBaseElement;
        (tagName: "basefont", attribute?: Attribute): FHTMLBaseFontElement;
        (tagName: "bdo", attribute?: Attribute): FHTMLElement;
        (tagName: "big", attribute?: Attribute): FHTMLElement;
        (tagName: "blockquote", attribute?: Attribute): FHTMLQuoteElement;
        (tagName: "body", attribute?: Attribute): FHTMLBodyElement;
        (tagName: "br", attribute?: Attribute): FHTMLBRElement;
        (tagName: "button", attribute?: Attribute): FHTMLButtonElement;
        (tagName: "canvas", attribute?: Attribute): FHTMLCanvasElement;
        (tagName: "caption", attribute?: Attribute): FHTMLTableCaptionElement;
        (tagName: "center", attribute?: Attribute): FHTMLElement;
        (tagName: "cite", attribute?: Attribute): FHTMLElement;
        (tagName: "code", attribute?: Attribute): FHTMLElement;
        (tagName: "col", attribute?: Attribute): FHTMLTableColElement;
        (tagName: "colgroup", attribute?: Attribute): FHTMLTableColElement;
        (tagName: "datalist", attribute?: Attribute): FHTMLDataListElement;
        (tagName: "dd", attribute?: Attribute): FHTMLElement;
        (tagName: "del", attribute?: Attribute): FHTMLModElement;
        (tagName: "dfn", attribute?: Attribute): FHTMLElement;
        (tagName: "dir", attribute?: Attribute): FHTMLDirectoryElement;
        (tagName?: "div", attribute?: Attribute): FHTMLDivElement;
        (tagName: "dl", attribute?: Attribute): FHTMLDListElement;
        (tagName: "dt", attribute?: Attribute): FHTMLElement;
        (tagName: "em", attribute?: Attribute): FHTMLElement;
        (tagName: "embed", attribute?: Attribute): FHTMLEmbedElement;
        (tagName: "fieldset", attribute?: Attribute): FHTMLFieldSetElement;
        (tagName: "font", attribute?: Attribute): FHTMLFontElement;
        (tagName: "form", attribute?: Attribute): FHTMLFormElement;
        (tagName: "frame", attribute?: Attribute): FHTMLFrameElement;
        (tagName: "frameset", attribute?: Attribute): FHTMLFrameSetElement;
        (tagName: "h1", attribute?: Attribute): FHTMLHeadingElement;
        (tagName: "h2", attribute?: Attribute): FHTMLHeadingElement;
        (tagName: "h3", attribute?: Attribute): FHTMLHeadingElement;
        (tagName: "h4", attribute?: Attribute): FHTMLHeadingElement;
        (tagName: "h5", attribute?: Attribute): FHTMLHeadingElement;
        (tagName: "h6", attribute?: Attribute): FHTMLHeadingElement;
        (tagName: "head", attribute?: Attribute): FHTMLHeadElement;
        (tagName: "hr", attribute?: Attribute): FHTMLHRElement;
        (tagName: "html", attribute?: Attribute): FHTMLHtmlElement;
        (tagName: "i", attribute?: Attribute): FHTMLElement;
        (tagName: "iframe", attribute?: Attribute): FHTMLIFrameElement;
        (tagName: "img", attribute?: Attribute): FHTMLImageElement;
        (tagName: "input", attribute?: Attribute): FHTMLInputElement;
        (tagName: "ins", attribute?: Attribute): FHTMLModElement;
        (tagName: "isindex", attribute?: Attribute): FHTMLUnknownElement;
        (tagName: "kbd", attribute?: Attribute): FHTMLElement;
        (tagName: "keygen", attribute?: Attribute): FHTMLElement;
        (tagName: "label", attribute?: Attribute): FHTMLLabelElement;
        (tagName: "legend", attribute?: Attribute): FHTMLLegendElement;
        (tagName: "li", attribute?: Attribute): FHTMLLIElement;
        (tagName: "link", attribute?: Attribute): FHTMLLinkElement;
        (tagName: "listing", attribute?: Attribute): FHTMLPreElement;
        (tagName: "map", attribute?: Attribute): FHTMLMapElement;
        (tagName: "marquee", attribute?: Attribute): FHTMLMarqueeElement;
        (tagName: "menu", attribute?: Attribute): FHTMLMenuElement;
        (tagName: "meta", attribute?: Attribute): FHTMLMetaElement;
        (tagName: "nextid", attribute?: Attribute): FHTMLUnknownElement;
        (tagName: "nobr", attribute?: Attribute): FHTMLElement;
        (tagName: "object", attribute?: Attribute): FHTMLObjectElement;
        (tagName: "ol", attribute?: Attribute): FHTMLOListElement;
        (tagName: "optgroup", attribute?: Attribute): FHTMLOptGroupElement;
        (tagName: "option", attribute?: Attribute): FHTMLOptionElement;
        (tagName: "p", attribute?: Attribute): FHTMLParagraphElement;
        (tagName: "param", attribute?: Attribute): FHTMLParamElement;
        (tagName: "plaintext", attribute?: Attribute): FHTMLElement;
        (tagName: "pre", attribute?: Attribute): FHTMLPreElement;
        (tagName: "progress", attribute?: Attribute): FHTMLProgressElement;
        (tagName: "q", attribute?: Attribute): FHTMLQuoteElement;
        (tagName: "rt", attribute?: Attribute): FHTMLElement;
        (tagName: "ruby", attribute?: Attribute): FHTMLElement;
        (tagName: "s", attribute?: Attribute): FHTMLElement;
        (tagName: "samp", attribute?: Attribute): FHTMLElement;
        (tagName: "script", attribute?: Attribute): FHTMLScriptElement;
        (tagName: "select", attribute?: Attribute): FHTMLSelectElement;
        (tagName: "small", attribute?: Attribute): FHTMLElement;
        (tagName: "source", attribute?: Attribute): FHTMLSourceElement;
        (tagName: "span", attribute?: Attribute): FHTMLSpanElement;
        (tagName: "strike", attribute?: Attribute): FHTMLElement;
        (tagName: "strong", attribute?: Attribute): FHTMLElement;
        (tagName: "style", attribute?: Attribute): FHTMLStyleElement;
        (tagName: "sub", attribute?: Attribute): FHTMLElement;
        (tagName: "sup", attribute?: Attribute): FHTMLElement;
        (tagName: "table", attribute?: Attribute): FHTMLTableElement;
        (tagName: "tbody", attribute?: Attribute): FHTMLTableSectionElement;
        (tagName: "td", attribute?: Attribute): FHTMLTableDataCellElement;
        (tagName: "textarea", attribute?: Attribute): FHTMLTextAreaElement;
        (tagName: "tfoot", attribute?: Attribute): FHTMLTableSectionElement;
        (tagName: "th", attribute?: Attribute): FHTMLTableHeaderCellElement;
        (tagName: "thead", attribute?: Attribute): FHTMLTableSectionElement;
        (tagName: "title", attribute?: Attribute): FHTMLTitleElement;
        (tagName: "tr", attribute?: Attribute): FHTMLTableRowElement;
        (tagName: "track", attribute?: Attribute): FHTMLTrackElement;
        (tagName: "tt", attribute?: Attribute): FHTMLElement;
        (tagName: "u", attribute?: Attribute): FHTMLElement;
        (tagName: "ul", attribute?: Attribute): FHTMLUListElement;
        (tagName: "var", attribute?: Attribute): FHTMLElement;
        (tagName: "video", attribute?: Attribute): FHTMLVideoElement;
        (tagName: "xmp", attribute?: Attribute): FHTMLPreElement;
        (tagName: string, attribute?: Attribute): FHTMLElement;
    }
    export interface Instance {
        readonly isFlagrated: boolean;
        /** Tells whether `element` is visible. */
        visible(): boolean;
        /** Tells whether `element` is exists on document. */
        exists(): boolean;
        /** Toggles the visibility of `element`. */
        toggle(): this;
        /** Sets `display: none` on `element`. */
        hide(): this;
        /** Removes `display: none` on `element`. */
        show(): this;
        /** Completely removes `element` from the document. */
        /** Clear the _content_ of `element`. */
        update(): this;
        /** Update the _content_ of `element` with the `string` as HTML. */
        update(string: string): this;
        /** **DEPRECATED**: Use updateText instead. */
        update(number: number): this;
        /** Replaces the _content_ of `element` with the `newContent`. */
        update<T extends Node>(newContent: T): this;
        /** Update the _content_ of `element` with the `string` as Text. */
        updateText(string: string | number | boolean): this;
        /** Update the _content_ of `element` with the `content` element as Text. */
        updateText<T extends Node>(content: T): this;
        /** Insert the `string` as HTML to the _content_ of `element`. */
        insert(string: string): this;
        /** **DEPRECATED**: Use updateText instead. */
        insert(number: number): this;
        /** Insert the `content` to the _content_ of `element`. */
        insert<T extends Node>(content: T): this;
        /** Insert the content(s) to the specific position of _content_ of `element` (Advanced).  */
        insert(insertion: Insertion): this;
        /** Insert the `string` to the _content_ of `element` */
        insertText(string: string | number | boolean): this;
        /** Insert the content(s) to the specific position of _content_ of `element` (Advanced). */
        insertText(content: Insertion): this;
        /** Insert `element` to the _content_ of `element`. */
        insertTo<T extends Node>(to: T): this;
        /** Insert `element` to the specific position of _content_ of `element`. */
        insertTo<T extends Node>(to: T, position: InsertPosition): this;
        /** **DEPRECATED**: Use getAttribute instead. */
        readAttribute(name: string): string;
        /** Set attribute `name`. */
        writeAttribute(name: string): this;
        /** Set or Remove attribute `name`. */
        writeAttribute(name: string, value: string): this;
        /** Set value of attribute `name`. */
        writeAttribute(name: string, exists: boolean): this;
        /** Set attribute(s) by name/value pairs. */
        writeAttribute(object: Attribute): this;
        /** Get dimenstions of `element`. */
        getDimensions(): Dimensions;
        /** Get height of `element`. */
        getHeight(): number;
        /** Get width of `element`. */
        getWidth(): number;
        /** Get cumulative offset of `element`. */
        cumulativeOffset(): Offset;
        /** Get cumulative scroll offset of `element`. */
        cumulativeScrollOffset(): Offset;
        /** Tells weather class name is exists. */
        hasClassName(className: string): boolean;
        /** Add class name to `element`. */
        addClassName(className: string): this;
        /** Remove class name from `element`. */
        removeClassName(className: string): this;
        /** Toggles the class name of `element`. */
        toggleClassName(className: string): this;
        /** Get value of style property of `element`. */
        getStyle(propertyName: NumberProperty): number;
        /** Get value of style property of `element`. */
        getStyle(propertyName: string): string;
        /** Set value of style property of `element`. */
        setStyle(style: Property): this;
        /** Registers an event handler on a DOM element. */
        on(eventType: string, listener: EventListener, useCapture?: boolean): this;
        /** Unregisters an event handler on a DOM element. */
        off(eventType: string, listener?: EventListener, useCapture?: boolean): this;
        /** Fires a custom event. */
        fire(eventType: string, property?: any): this;
        /** Emit a custom event. (alias of fire) */
        emit(eventType: string, property?: any): this;
    }
    export type Attribute = {
        [name: string]: string | boolean;
    };
    export type Property = {
        [name: string]: string;
    };
    export type NumberProperty = "opacity";
    export type InsertPosition = "before" | "top" | "bottom" | "after";
    export interface Insertion {
        before?: HTMLElement | string | number;
        top?: HTMLElement | string | number;
        bottom?: HTMLElement | string | number;
        after?: HTMLElement | string | number;
    }
    export interface Dimensions {
        readonly width: number;
        readonly height: number;
    }
    export interface Offset {
        readonly top: number;
        readonly left: number;
    }
    export const Element: Class;
    export const createElement: createElement;
}
declare module "flagrate/button" {
    import { Attribute, Property, FHTMLSpanElement, FHTMLButtonElement } from "flagrate/element";
    export interface Button extends Instance, FHTMLButtonElement {
    }
    export interface Class {
        new (option?: Option): Button;
        prototype: Instance;
    }
    export interface Instance {
        select(): this;
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        setLabel(label: string): this;
        setLabelHTML(html: string): this;
        setColor(color?: string): this;
        getColor(): string;
        setIcon(url?: string): this;
        getIcon(): string;
        onSelect?(event?: ButtonEvent, button?: this): void;
        onRemove?(event?: ButtonEvent, button?: this): void;
        readonly labelElement?: FHTMLSpanElement;
        _removeButton?: FHTMLButtonElement;
        _color?: string;
        _iconIdentifier?: string;
        _onSelectHandler(event: MouseEvent): void;
        _onRemoveHandler(event: MouseEvent): void;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** Color (uses flagrate.Button#setColor). */
        color?: string;
        /** Label text. */
        label?: string;
        /** Label html. */
        labelHTML?: string;
        /** icon image URL. */
        icon?: string;
        /** default is false. */
        isFocused?: boolean;
        /** default is false. */
        isDisabled?: boolean;
        /** default is false. */
        isRemovableByUser?: boolean;
        onSelect?(event?: ButtonEvent, button?: Button): void;
        onRemove?(event?: ButtonEvent, button?: Button): void;
    }
    export interface ButtonEvent extends MouseEvent {
        targetButton?: Button;
    }
    export const Button: Class;
    export function createButton(option?: Option): Button;
}
declare module "flagrate/buttons" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import * as button from "flagrate/button";
    export interface Buttons extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Buttons;
        prototype: Instance;
    }
    export interface Instance {
        push(button: ButtonOption): this;
        getButtonByKey(key: string): button.Button;
        getButtons(): button.Button[];
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** Button items */
        items?: ButtonOption[];
        onSelect?(event?: button.ButtonEvent, buttons?: Buttons): void;
    }
    export interface ButtonOption extends button.Option {
        /** key */
        key?: string;
    }
    export const Buttons: Class;
    export function createButtons(option?: Option): Buttons;
}
declare module "flagrate/menu" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import * as button from "flagrate/button";
    export interface Menu extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Menu;
        prototype: Instance;
    }
    export interface Instance {
        push(item: ItemOption): this;
        getButtonByKey(key: string): button.Button;
        getButtons(): button.Button[];
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** Button items */
        items?: ItemOption[];
        onSelect?(event?: button.ButtonEvent, menu?: Menu): void;
    }
    export interface ItemOption extends button.Option {
        /** key */
        key?: string;
    }
    export const Menu: Class;
    export function createMenu(option?: Option): Menu;
}
declare module "flagrate/pulldown" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Button, ButtonEvent } from "flagrate/button";
    import { ItemOption } from "flagrate/menu";
    export interface Pulldown extends Instance, Button {
    }
    export interface Class {
        new (option?: Option): Pulldown;
        prototype: Instance;
    }
    export interface Instance {
        items?: ItemOption[];
        open(event?: any): this;
        close(event?: any): this;
        onOpen?(event?: ButtonEvent, button?: this): void;
        onClose?(event?: ButtonEvent, button?: this): void;
        _menu?: FHTMLDivElement;
        _open?: boolean;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** Color (uses flagrate.Button#setColor). */
        color?: string;
        /** Label text. */
        label?: string;
        /** icon image URL. */
        icon?: string;
        /** default is false. */
        isDisabled?: boolean;
        /** Button items */
        items?: ItemOption[];
        onSelect?(event?: ButtonEvent, button?: Pulldown): void;
        onOpen?(event?: any, button?: Pulldown): void;
        onClose?(event?: any, button?: Pulldown): void;
    }
    export const Pulldown: Class;
    export function createPulldown(option?: Option): Pulldown;
}
declare module "flagrate/text-input" {
    import { Attribute, Property, FHTMLInputElement } from "flagrate/element";
    export interface TextInput extends Instance, FHTMLInputElement {
    }
    export interface Class {
        new (option?: Option): TextInput;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        setValue(value: string): this;
        getValue(): string;
        setIcon(url?: string): this;
        getIcon(): string;
        isValid(): boolean;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** default value. */
        value?: string;
        /** placeholder. */
        placeholder?: string;
        /** icon image URL. */
        icon?: string;
        /** RegExp for simple validation feature. */
        regexp?: RegExp;
        /** default is false. */
        isDisabled?: boolean;
    }
    export const TextInput: Class;
    export function createTextInput(option?: Option): TextInput;
}
declare module "flagrate/tokenizer" {
    import { Attribute, Property, FHTMLSpanElement, FHTMLDivElement } from "flagrate/element";
    import { TextInput } from "flagrate/text-input";
    export interface Tokenizer extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Tokenizer;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        setValues(values: (string | Value)[]): this;
        getValues(): (string | Value)[];
        removeValues(): this;
        removeValue(value: string | Value): this;
        setIcon(url?: string): this;
        getIcon(): string;
        focus(): void;
        onChange?(event?: any, tokenizer?: this): void;
        values?: (string | Value)[];
        max?: number;
        _updateTokens(): this;
        _tokenize(): this;
        _tokenized(candidates: (string | Value)[]): this;
        _tokenized(candidates: string | Value): this;
        _onClickHandler(event: MouseEvent): void;
        _onKeydownHandler(event: KeyboardEvent): void;
        _onFocusHandler(event: FocusEvent): void;
        _onBlurHandler(event: FocusEvent): void;
        _tokens?: FHTMLSpanElement;
        _input?: TextInput;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses Flagrate.Element.setStyle). */
        style?: Property;
        /** default values. */
        values?: Value[];
        /** default is `-1`. */
        max?: number;
        /** placeholder. */
        placeholder?: string;
        /** icon image URL. */
        icon?: string;
        /** default is Flagrate.identity */
        tokenize?(input: string, done: TokenizedCallback): void;
        tokenizeSync?(input: string): (string | Value)[];
        /** default is false. */
        isDisabled?: boolean;
        onChange?(event?: any, tokenizer?: Tokenizer): void;
    }
    export interface TokenizedCallback {
        (output: (string | Value)[]): void;
        (output: string | Value): void;
    }
    export interface Value {
        label: string;
        value: any;
    }
    export const Tokenizer: Class;
    export function createTokenizer(option?: Option): Tokenizer;
}
declare module "flagrate/text-area" {
    import { Attribute, Property, FHTMLTextAreaElement } from "flagrate/element";
    export interface TextArea extends Instance, FHTMLTextAreaElement {
    }
    export interface Class {
        new (option?: Option): TextArea;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        setValue(value: string): this;
        getValue(): string;
        setIcon(url?: string): this;
        getIcon(): string;
        isValid(): boolean;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** default value. */
        value?: string;
        /** placeholder. */
        placeholder?: string;
        /** icon image URL. */
        icon?: string;
        /** RegExp for simple validation feature. */
        regexp?: RegExp;
        /** default is false. */
        isDisabled?: boolean;
    }
    export const TextArea: Class;
    export function createTextArea(option?: Option): TextArea;
}
declare module "flagrate/combo-box" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Button } from "flagrate/button";
    import { Menu } from "flagrate/menu";
    import { TextInput } from "flagrate/text-input";
    export interface ComboBox extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): ComboBox;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        getValue(): any;
        setValue(value: string): this;
        setIcon(url?: string): this;
        getIcon(): string;
        isValid(): boolean;
        items?: string[];
        /** RegExp for simple validation feature. */
        regexp?: RegExp;
        _textinput?: TextInput;
        _button?: Button;
        _menu?: Menu;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** default value. */
        value?: string;
        /** Array of string values. */
        items?: string[];
        /** placeholder. */
        placeholder?: string;
        /** icon image URL. */
        icon?: string;
        /** RegExp for simple validation feature. */
        regexp?: RegExp;
        /** default is false. */
        isDisabled?: boolean;
    }
    export const ComboBox: Class;
    export function createComboBox(option?: Option): ComboBox;
}
declare module "flagrate/checkbox" {
    import { Attribute, FHTMLLabelElement, FHTMLInputElement } from "flagrate/element";
    export interface Checkbox extends Instance, FHTMLLabelElement {
    }
    export interface Class {
        new (option?: Option): Checkbox;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        isChecked(): boolean;
        check(): this;
        uncheck(): this;
        onChange?(e: CheckboxEvent, target: this): void;
        onCheck?(e: CheckboxEvent, target: this): void;
        onUncheck?(e: CheckboxEvent, target: this): void;
        _input?: FHTMLInputElement;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** Label text. */
        label?: string;
        /** Label HTML. */
        labelHTML?: string;
        /** icon image URL. */
        icon?: string;
        /** default is false. */
        isChecked?: boolean;
        /** default is false. */
        isFocused?: boolean;
        /** default is false. */
        isDisabled?: boolean;
        onChange?(e?: CheckboxEvent, target?: Checkbox): void;
        onCheck?(e?: CheckboxEvent, target?: Checkbox): void;
        onUncheck?(e?: CheckboxEvent, target?: Checkbox): void;
    }
    export interface CheckboxEvent extends Event {
        targetCheckbox?: Checkbox;
    }
    export const Checkbox: Class;
    export function createCheckbox(option?: Option): Checkbox;
}
declare module "flagrate/toolbar" {
    import { Attribute, Property, FHTMLElement, FHTMLDivElement } from "flagrate/element";
    export interface Toolbar extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Toolbar;
        prototype: Instance;
    }
    export interface Instance {
        push(item: ItemOption): this;
        getElementByKey(key: string): FHTMLElement;
        getElements(): FHTMLElement[];
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses Flagrate.Element.setStyle). */
        style?: Property;
        /** items */
        items?: ItemOption[];
    }
    export interface ItemOption {
        /** key */
        key?: string;
        /** element */
        element?: FHTMLElement;
        /** if this true ignores element option */
        isBorder?: boolean;
    }
    export const Toolbar: Class;
    export function createToolbar(option?: Option): Toolbar;
}
declare module "flagrate/context-menu" {
    import { ItemOption } from "flagrate/menu";
    export interface Option {
        /** target element */
        target?: HTMLElement;
        /** Button items */
        items?: ItemOption[];
    }
    export class ContextMenu {
        items: ItemOption[];
        private _target;
        private _isShowing;
        private _menu;
        private _openHandler;
        private _closeHandler;
        constructor(option?: Option);
        setTarget(target: HTMLElement): this;
        open(e?: MouseEvent): this;
        close(): this;
        /** Tells whether the visibility. */
        visible(): boolean;
        /** remove the elements and listeners. */
        remove(): void;
    }
    export function createContextMenu(option?: Option): ContextMenu;
}
declare module "flagrate/grid" {
    import { Attribute, Property, InsertPosition, FHTMLDivElement, FHTMLTableDataCellElement, FHTMLTableRowElement, FHTMLTableHeaderCellElement } from "flagrate/element";
    import { ItemOption as MenuItemOption } from "flagrate/menu";
    import { Checkbox } from "flagrate/checkbox";
    import { ContextMenu } from "flagrate/context-menu";
    export interface Option {
        /** `id` attribute of container. */
        id?: string;
        className?: string;
        attribute?: Attribute;
        style?: Property;
        cols?: ColOption[];
        rows?: RowOption[];
        /** default is `16`. */
        colMinWidth?: number;
        /** default is `false`. */
        pagination?: boolean;
        /** default is `20`. */
        numberOfRowsPerPage?: number;
        /** default is `false`. */
        fill?: boolean;
        /** default is `false`. */
        headless?: boolean;
        /** default is `false`. */
        multiSelect?: boolean;
        /** default is `false`. */
        disableCheckbox?: boolean;
        /** default is `false`. */
        disableSelect?: boolean;
        /** default is `false`. */
        disableSort?: boolean;
        /** default is `false`. */
        disableResize?: boolean;
        onSelect?(event?: Event, row?: Row, grid?: Grid): void;
        onDeselect?(event?: Event, row?: Row, grid?: Grid): void;
        onClick?(event?: MouseEvent, row?: Row, grid?: Grid): void;
        onDblClick?(event?: MouseEvent, row?: Row, grid?: Grid): void;
        onRender?(grid?: Grid): boolean;
        onRendered?(grid?: Grid): void;
        postProcessOfRow?(tr?: FHTMLTableRowElement, row?: Row, grid?: Grid): void;
    }
    export interface Col extends ColOption {
        readonly isSorted?: boolean;
        readonly isAsc?: boolean;
        _id?: string;
        _th?: FHTMLTableHeaderCellElement;
        _div?: FHTMLDivElement;
        _resizeHandle?: FHTMLDivElement;
    }
    export interface ColOption {
        /** `id` attribute of `th` */
        id?: string;
        className?: string;
        attribute?: Attribute;
        style?: Property;
        key: string;
        label?: string;
        icon?: string;
        align?: TextAlign;
        width?: number;
        minWidth?: number;
        /** default is `false`. */
        disableSort?: boolean;
        /** default is `false`. */
        disableResize?: boolean;
    }
    export interface Row extends RowOption {
        cell?: {
            [colKey: string]: string | number | Cell;
        };
        readonly tr?: FHTMLTableRowElement;
        _grid?: Grid;
        _tr?: FHTMLTableRowElement;
        _checkbox?: Checkbox;
        _last?: FHTMLTableDataCellElement;
        _menu?: ContextMenu;
    }
    export interface RowOption {
        /** `id` attribute of `tr` */
        id?: string;
        className?: string;
        attribute?: Attribute;
        style?: Property;
        cell?: {
            [colKey: string]: string | number | CellOption;
        };
        menuItems?: MenuItemOption[];
        isSelected?: boolean;
        onSelect?(event?: Event, row?: Row, grid?: Grid): void;
        onDeselect?(event?: Event, row?: Row, grid?: Grid): void;
        onClick?(event?: MouseEvent, row?: Row, grid?: Grid): void;
        onDblClick?(event?: MouseEvent, row?: Row, grid?: Grid): void;
        postProcess?(tr?: FHTMLTableRowElement, row?: Row, grid?: Grid): void;
        /** value of row. this will disables cell's value. */
        value?: any;
    }
    export interface Cell extends CellOption {
        readonly td?: FHTMLTableDataCellElement;
        readonly div?: FHTMLDivElement;
        _td?: FHTMLTableDataCellElement;
        _div?: FHTMLDivElement;
    }
    export interface CellOption {
        /** `id` attribute of `td` */
        id?: string;
        className?: string;
        attribute?: Attribute;
        style?: Property;
        text?: string | number;
        html?: string;
        element?: HTMLElement;
        icon?: string;
        sortAlt?: number | string;
        onClick?(event?: MouseEvent, cell?: Cell, grid?: Grid): void;
        onDblClick?(event?: MouseEvent, cell?: Cell, grid?: Grid): void;
        postProcess?(td?: FHTMLTableDataCellElement, cell?: Cell, grid?: Grid): void;
        /** value of cell. */
        value?: any;
    }
    export type TextAlign = "left" | "center" | "right";
    export class Grid {
        private _opt;
        private _cols;
        private _rows;
        private _pagePosition;
        onSelect: (event?: Event, row?: Row, grid?: Grid) => void;
        onDeselect: (event?: Event, row?: Row, grid?: Grid) => void;
        onClick: (event?: MouseEvent, row?: Row, grid?: Grid) => void;
        onDblClick: (event?: MouseEvent, row?: Row, grid?: Grid) => void;
        onRender: (grid?: Grid) => boolean;
        onRendered: (grid?: Grid) => void;
        postProcessOfRow: (tr?: FHTMLTableRowElement, row?: Row, grid?: Grid) => void;
        private _selectedRows;
        private _sortedByKey;
        private _sortedByAsc;
        element: FHTMLDivElement;
        private _checkbox;
        private _pager;
        private _lastCol;
        private _head;
        private _thead;
        private _tr;
        private _body;
        private _tbody;
        private _style;
        static idCounter: number;
        private _id;
        private _renderTimer;
        private _layoutTimer;
        private _layoutInterval;
        private _layoutWidth;
        constructor(_opt?: Option);
        headless: boolean;
        fill: boolean;
        rows: Row[];
        readonly sortedByKey: string;
        readonly sortedByAsc: boolean;
        selectedRows: Row[];
        insertTo(element: HTMLElement, pos?: InsertPosition): this;
        on(eventType: string, listener: EventListener, useCapture?: boolean): this;
        off(eventType: string, listener?: EventListener, useCapture?: boolean): this;
        /** select row(s) */
        select(...row: (number | Row)[]): this;
        select(rows: (number | Row)[]): this;
        /** deselect row(s) */
        deselect(...row: (number | Row)[]): this;
        deselect(rows: (number | Row)[]): this;
        /** select all rows */
        selectAll(): this;
        /** deselect all rows */
        deselectAll(): this;
        /** get selected rows */
        getSelectedRows(): Row[];
        /** get values of selected rows */
        getValues(): any[];
        /** sort rows by key */
        sort(key: string, isAsc?: boolean): this;
        unshift(row: Row): number;
        unshift(rows: Row[]): number;
        push(row: Row): number;
        push(rows: Row[]): number;
        shift(count?: number): Row | Row[];
        pop(count?: number): Row | Row[];
        splice(index: number, howMany?: number, rows?: Row[]): Row[];
        splice(index: number, howMany?: number, row?: Row): Row[];
        indexOf(row: Row, fromIndex?: number): number;
        removeRow(row: Row): Row;
        removeRow(rows: Row[]): Row[];
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        private _create();
        private _layoutUpdater();
        private _requestUpdateLayout();
        private _requestRender();
        private _render();
        private _updateRowMenu(row, items);
        private _updatePositionOfResizeHandles();
        private _updateLayoutOfCols(surplus?);
        private _createOnScrollHandler();
        private _createBodyOnScrollHandler();
        private _createColOnClickHandler(col);
        private _createRowOnClickHandler(row);
        private _createRowOnDblClickHandler(row);
        private _createCellOnClickHandler(cell);
        private _createCellOnDblClickHandler(cell);
        private _createRowOnCheckHandler(row);
        private _createLastRowOnClickHandler(row);
        private _createResizeHandleOnMousedownHandler(col);
    }
    export function createGrid(a: any): Grid;
}
declare module "flagrate/select" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Pulldown } from "flagrate/pulldown";
    import { Grid } from "flagrate/grid";
    export interface Select extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Select;
        prototype: Instance;
    }
    export interface Instance {
        select(index: number): this;
        deselect(index: number): this;
        selectAll(): this;
        deselectAll(): this;
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        getValue(): any;
        getValues(): any[];
        onChange?(event?: any, menu?: this): void;
        readonly listView?: boolean;
        readonly multiple?: boolean;
        readonly items?: ItemOption[];
        readonly max?: number;
        readonly selectedIndex?: number;
        readonly selectedIndexes?: number[];
        readonly isPulldown?: boolean;
        _pulldown?: Pulldown;
        _grid?: Grid;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** default is false. */
        listView?: boolean;
        /** default is false. */
        multiple?: boolean;
        /** default is -1 (unlimited). */
        max?: number;
        /** Array of any value or, SelectItemOption object. */
        items?: ItemOption[];
        selectedIndex?: number;
        selectedIndexes?: number[];
        /** default is false. */
        isDisabled?: boolean;
    }
    export type ItemOption = string | number | {
        /** if not specifies label, tries convert value to string for display label. */
        label?: string;
        labelHTML?: string;
        /** icon image URL. */
        icon?: string;
        /** value. */
        value: any;
    };
    export const Select: Class;
    export function createSelect(option?: Option): Select;
}
declare module "flagrate/search-box" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Button } from "flagrate/button";
    import { TextInput } from "flagrate/text-input";
    export interface SearchBox extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): SearchBox;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        getValue(): string;
        setValue(value: string): this;
        search(): this;
        suggest(): this;
        focus(): void;
        blur(): void;
        _suggested(items: (string | SuggestedItem)[]): void;
        _onKeydownHandler(e: KeyboardEvent): void;
        _onKeyupHandler(e: KeyboardEvent): void;
        _onFocusHandler(e: FocusEvent): void;
        _onBlurHandler(e: FocusEvent): void;
        _input?: TextInput;
        _button?: Button;
        _suggest?: FHTMLDivElement;
    }
    export interface Option {
        id?: string;
        className?: string;
        attribute?: Attribute;
        style?: Property;
        value?: string;
        placeholder?: string;
        icon?: string;
        isDisabled?: boolean;
        suggester?(value: string, callback: (items: (string | SuggestedItem)[]) => void): void;
        suggester?(value: string): (string | SuggestedItem)[];
        onSearch?(value?: string, target?: SearchBox): void;
    }
    export interface SuggestedItem {
        label: string;
        icon?: string;
        onSelect?(): void;
    }
    export const SearchBox: Class;
    export function createSearchBox(option?: Option): SearchBox;
}
declare module "flagrate/checkboxes" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Checkbox, Option as _CheckboxOption, CheckboxEvent } from "flagrate/checkbox";
    export interface Checkboxes extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Checkboxes;
        prototype: Instance;
    }
    export interface Instance {
        select(index: number): this;
        deselect(index: number): this;
        selectAll(): this;
        deselectAll(): this;
        getValues(): any[];
        addValue(value: any): this;
        removeValue(value: any): this;
        setValues(values: any[]): this;
        selectAll(): this;
        deselectAll(): this;
        enable(): this;
        disable(): this;
        isEnabled(): boolean;
        onChange?(event: CheckboxEvent, target: this): void;
        _items?: CheckboxesItem[];
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** Button items */
        items?: (string | number | boolean | CheckboxOption)[];
        /** default value */
        values?: any[];
        /** default is false. */
        isDisabled?: boolean;
        onChange?(event?: CheckboxEvent, target?: Checkboxes): void;
    }
    export interface CheckboxOption extends _CheckboxOption {
        label: string;
        value: any;
    }
    export interface CheckboxesItem extends CheckboxOption {
        _checkbox?: Checkbox;
    }
    export const Checkboxes: Class;
    export function createCheckboxes(option?: Option): Checkboxes;
}
declare module "flagrate/radio" {
    import { Attribute, FHTMLLabelElement, FHTMLInputElement } from "flagrate/element";
    export interface Radio extends Instance, FHTMLLabelElement {
    }
    export interface Class {
        new (option?: Option): Radio;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        isChecked(): boolean;
        check(): this;
        uncheck(): this;
        onChange?(e: RadioEvent, target: this): void;
        onCheck?(e: RadioEvent, target: this): void;
        onUncheck?(e: RadioEvent, target: this): void;
        _input?: FHTMLInputElement;
        _checked?: boolean;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** name attribute. */
        name?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** Label text. */
        label?: string;
        /** Label HTML. */
        labelHTML?: string;
        /** icon image URL. */
        icon?: string;
        /** default is false. */
        isChecked?: boolean;
        /** default is false. */
        isFocused?: boolean;
        /** default is false. */
        isDisabled?: boolean;
        onChange?(e?: RadioEvent, target?: Radio): void;
        onCheck?(e?: RadioEvent, target?: Radio): void;
        onUncheck?(e?: RadioEvent, target?: Radio): void;
    }
    export interface RadioEvent extends Event {
        targetRadio?: Radio;
    }
    export const Radio: Class;
    export function createRadio(option?: Option): Radio;
}
declare module "flagrate/radios" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Radio, Option as _RadioOption, RadioEvent } from "flagrate/radio";
    export interface Radios extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Radios;
        prototype: Instance;
    }
    export interface Instance {
        select(index: number): this;
        getValue(): any;
        setValue(value: any): this;
        enable(): this;
        disable(): this;
        isEnabled(): boolean;
        onChange?(event: RadioEvent, target: this): void;
        selectedIndex?: number;
        _items?: RadiosItem[];
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** Button items */
        items?: (string | number | boolean | RadioOption)[];
        /** default selectedIndex */
        selectedIndex?: number;
        /** default is false. */
        isDisabled?: boolean;
        onChange?(event?: RadioEvent, target?: Radios): void;
    }
    export interface RadioOption extends _RadioOption {
        label: string;
        value: any;
    }
    export interface RadiosItem extends RadioOption {
        _radio?: Radio;
    }
    export const Radios: Class;
    export function createRadios(option?: Option): Radios;
}
declare module "flagrate/switch" {
    import { Attribute, Property } from "flagrate/element";
    import { Button } from "flagrate/button";
    export interface Switch extends Instance, Button {
    }
    export interface Class {
        new (option?: Option): Switch;
        prototype: Instance;
    }
    export interface Instance {
        isOn(): boolean;
        switchOn(): this;
        switchOff(): this;
        toggleSwitch(): this;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** CSS style properties (uses flagrate.Element.setStyle). */
        style?: Property;
        /** default is false. */
        isFocused?: boolean;
        /** default is false. */
        isDisabled?: boolean;
        /** default is false. */
        isOn?: boolean;
    }
    export const Switch: Class;
    export function createSwitch(option?: Option): Switch;
}
declare module "flagrate/progress" {
    import { Attribute, FHTMLDivElement } from "flagrate/element";
    export interface Progress extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Progress;
        prototype: Instance;
    }
    export interface Instance {
        getValue(): number;
        setValue(value: number): this;
        getMax(): number;
        setMax(value: number): this;
        _max?: number;
        _value?: number;
        _bar?: FHTMLDivElement;
        _updateProgress?(): void;
    }
    export interface Option {
        /** id attribute. */
        id?: string;
        /** class attribute. */
        className?: string;
        /** attribute/value pairs properties. */
        attribute?: Attribute;
        /** default is `0`. */
        value?: number;
        /** default is `100`. */
        max?: number;
    }
    export const Progress: Class;
    export function createProgress(option?: Option): Progress;
}
declare module "flagrate/slider" {
    import * as progress from "flagrate/progress";
    export interface Slider extends Instance, progress.Progress {
    }
    export interface Class {
        new (option?: Option): Slider;
        prototype: Instance;
    }
    export interface Instance {
        disable(): this;
        enable(): this;
        isEnabled(): boolean;
        _onPointerDownHandler(e: PointerEvent): void;
        _onTouchStartHandler(e: TouchEvent): void;
        _slide(x: number, pos: number, type: "pointer" | "touch"): void;
    }
    export interface Option extends progress.Option {
        /** default is false. */
        isDisabled?: boolean;
    }
    export const Slider: Class;
    export function createSlider(option?: Option): Slider;
}
declare module "flagrate/tab" {
    import { Attribute, Property, FHTMLDivElement } from "flagrate/element";
    import { Button } from "flagrate/button";
    export interface Tab extends Instance, FHTMLDivElement {
    }
    export interface Class {
        new (option?: Option): Tab;
        prototype: Instance;
    }
    export interface Instance {
        /** select the tab by key. */
        select(tabKey: string): this;
        /** select the tab by index. */
        select(tabIndex: number): this;
        /** select the tab by same object. */
        select(tabItem: TabItem): this;
        /** unshift the tab. */
        unshift(tabItem: TabItem): number;
        /** unshift the tabs. */
        unshift(tabItems: TabItem[]): number;
        /** push the tab. */
        push(tabItem: TabItem): number;
        /** push the tabs. */
        push(tabItems: TabItem[]): number;
        /** shift the tab(s). */
        shift(count?: number): TabItem | TabItem[];
        /** pop the tabs. */
        pop(count?: number): TabItem | TabItem[];
        /** Changes the content of a tabs, adding new tabs while removing old tab(s). */
        splice(index: number, howMany?: number, tabItems?: TabItem[]): TabItem[];
        /** Changes the content of a tabs, adding new tab while removing old tab(s). */
        splice(index: number, howMany?: number, tabItem?: TabItem): TabItem[];
        /** remove tab by key. */
        removeTab(tabKey: string): TabItem;
        /** remove tab by index. */
        removeTab(tabIndex: number): TabItem;
        /** remove tab by same object. */
        removeTab(tabItem: TabItem): TabItem;
        /** remove tabs by same objects */
        removeTab(tabItems: TabItem[]): TabItem[];
        /** get index by key. */
        indexOf(tabKey: string): number;
        /** get index by same object. */
        indexOf(tabItem: TabItem): number;
        readonly tabs?: TabItem[];
        readonly bodyless?: boolean;
        readonly selectedIndex?: number;
        onSelect?(event?: TabEvent, tabItem?: TabItem): void;
        _tabs?: TabItem[];
        _bodyless?: boolean;
        _selectedIndex?: number;
        _head?: FHTMLDivElement;
        _body?: FHTMLDivElement;
        _create(): this;
        _render(): this;
        _createOnSelectHandler(tabItem: TabItem): (e: Event) => void;
    }
    export interface Option {
        id?: string;
        className?: string;
        attribute?: Attribute;
        style?: Property;
        tabs?: TabItemOption[];
        selectedIndex?: number;
        fill?: boolean;
        bodyless?: boolean;
        onSelect?(event?: TabEvent, tabItem?: TabItem): void;
    }
    export interface TabItem extends TabItemOption {
        _button?: Button;
    }
    export interface TabItemOption {
        key?: string;
        label?: string;
        icon?: string;
        text?: string;
        html?: string;
        element?: HTMLElement;
        onSelect?(event?: TabEvent, tabItem?: TabItem): void;
    }
    export interface TabEvent extends Event {
        targetTab?: Tab;
        targetTabItem?: TabItem;
    }
    export const Tab: Class;
    export function createTab(option?: Option): Tab;
}
declare module "flagrate/popover" {
    import { FHTMLElement } from "flagrate/element";
    export interface Option {
        target?: HTMLElement;
        text?: string;
        html?: string;
        element?: HTMLElement;
        className?: string;
    }
    export class Popover {
        private _target;
        private _text;
        private _html;
        private _element;
        private _className;
        private _div;
        private _positioningTimer;
        private _isShowing;
        private _openHandler;
        private _closeHandler;
        constructor(opt?: Option);
        target: FHTMLElement;
        text: string;
        html: string;
        element: HTMLElement;
        className: string;
        isShowing: boolean;
        open(forceTarget?: Event | HTMLElement): this;
        close(): this;
        visible(): boolean;
        remove(): void;
        setTarget(element: FHTMLElement): this;
        setText(text: string): this;
        setHTML(html: string): this;
        setElement(element: HTMLElement): this;
        setClassName(className: string): this;
        private _create();
    }
    export function createPopover(option?: Option): Popover;
}
declare module "flagrate/modal" {
    import { FHTMLDivElement } from "flagrate/element";
    import { Button } from "flagrate/button";
    export interface Option {
        /** default is `document.body`. */
        target?: HTMLElement;
        id?: string;
        className?: string;
        title?: string;
        subtitle?: string;
        text?: string;
        html?: string;
        element?: HTMLElement;
        content?: FHTMLDivElement;
        buttons?: ModalButtonOption[];
        /** default is `"flex"`. */
        sizing?: Sizing;
        onBeforeClose?(modal?: Modal, e?: Event): boolean;
        onClose?(modal?: Modal, e?: Event): void;
        onShow?(modal?: Modal): void;
        /** default is `false`. */
        disableCloseButton?: boolean;
        /** default is `false`. */
        disableCloseByMask?: boolean;
        /** default is `false`. */
        disableCloseByEsc?: boolean;
    }
    export type Sizing = "flex" | "full";
    export interface ModalButton extends ModalButtonOption {
        _button?: Button;
    }
    export interface ModalButtonOption {
        key?: string;
        label?: string;
        icon?: string;
        color?: string;
        onSelect?(e?: Event, modal?: Modal): void;
        isFocused?: boolean;
        isDisabled?: boolean;
        className?: string;
    }
    export class Modal {
        private _opt;
        private _content;
        private _buttons;
        onBeforeClose: (modal?: Modal, e?: Event) => boolean;
        onClose: (modal?: Modal, e?: Event) => void;
        onShow: (modal?: Modal) => void;
        private _container;
        private _obi;
        private _modal;
        private _closeButton;
        private _header;
        private _middle;
        private _footer;
        private _title;
        private _subtitle;
        private _positioningTimer;
        private _closingTimer;
        private _close;
        private __onKeydownHandler;
        constructor(_opt?: Option);
        readonly buttons: Button[];
        id: string;
        className: string;
        content: FHTMLDivElement;
        sizing: Sizing;
        element: HTMLElement;
        html: string;
        text: string;
        title: string;
        subtitle: string;
        setId(id: string): this;
        setClassName(className: string): this;
        setContent(div: FHTMLDivElement): this;
        setSizing(sizing: Sizing): this;
        setElement(element: HTMLElement): this;
        setHTML(html: string): this;
        setText(text: string): this;
        setTitle(title: string): this;
        setSubtitle(subtitle: string): this;
        visible(): boolean;
        open(): this;
        /** DEPRECATED */
        show(): this;
        /** DEPRECATED */
        render(): this;
        close(e?: Event): this;
        getButtonByKey(key: string): Button;
        getButtons(): Button[];
        setButtons(buttons: ModalButtonOption[]): this;
        private _create();
        private _createBase();
        private _createModal();
        private _createButtons();
        private _positioning();
        private _onKeydownHandler(e);
    }
    export function createModal(option?: Option): Modal;
}
declare module "flagrate/tutorial" {
    export interface Option {
        steps?: Step[];
        index?: number;
        onFinish?(tutorial?: this): void;
        onAbort?(tutorial?: this): void;
        onClose?(tutorial?: this): void;
    }
    export interface Step {
        /** Element to target. If target is undefined or not found, will creates flagrate.Modal. */
        target?: string | HTMLElement;
        /** Title for this step. */
        title?: string;
        /** Descriptive text for this step. */
        text?: string;
        /** Descriptive html for this step. */
        html?: string;
        /** Triggered whenever a step is started. */
        onStep?(): void;
        /** Triggered at before starting of this step. */
        onBeforeStep?(done?: AsyncCallback): void;
        /** Triggered at after of this step. */
        onAfterStep?(done?: AsyncCallback): void;
    }
    export interface AsyncCallback {
        (): void;
    }
    export interface ButtonOption {
        id?: string;
        className?: string;
        color?: string;
        label?: string;
        labelHTML?: string;
        icon?: string;
        isFocused?: boolean;
        isDisabled?: boolean;
        onSelect?(): void;
    }
    export class Tutorial {
        onFinish: (tutorial?: this) => void;
        onAbort: (tutorial?: this) => void;
        onClose: (tutorial?: this) => void;
        private _steps;
        private _index;
        private _popover;
        private _modal;
        private _inStep;
        constructor(opt?: Option);
        visible(): boolean;
        open(): this;
        close(): this;
        abort(): this;
        finish(): this;
        prev(): this;
        next(): this;
        private _main();
        private _step();
        _afterStep(done: AsyncCallback): this;
    }
    export function createTutorial(option?: Option): Tutorial;
}
declare module "flagrate/notify" {
    export interface Option {
        /** default is `document.body` */
        target?: HTMLElement;
        /** additional className for Notify. */
        className?: string;
        /** default is `false`. */
        disableDesktopNotify?: boolean;
        /** default is `false`. */
        disableFocusDetection?: boolean;
        /** default is `"right"`. */
        hAlign?: HorizontalAlign;
        /** default is `"bottom"`. */
        vAlign?: VerticalAlign;
        /** default is `10`. */
        hMargin?: number;
        /** default is `10`. */
        vMargin?: number;
        /** default is `10`. */
        spacing?: number;
        /** default is `5`. */
        timeout?: number;
        /** default is `"Notify"`. */
        title?: string;
        /** default icon URL. */
        icon?: string;
    }
    export interface CreateOption {
        title?: string;
        message?: string;
        body?: string;
        content?: string;
        text?: string;
        icon?: string;
        onClick?(): void;
        onClose?(): void;
        timeout?: number;
    }
    export type HorizontalAlign = "right" | "left";
    export type VerticalAlign = "top" | "bottom";
    export class Notify {
        target: HTMLElement;
        className: string;
        disableDesktopNotify: boolean;
        disableFocusDetection: boolean;
        hAlign: HorizontalAlign;
        vAlign: VerticalAlign;
        hMargin: number;
        vMargin: number;
        spacing: number;
        timeout: number;
        title: string;
        icon: string;
        private _notifies;
        constructor(opt?: Option);
        create(_opt?: CreateOption | string): this;
        private _init();
        private _createDesktopNotify(opt);
        private _positioner();
    }
    export function createNotify(option?: Option): Notify;
}
declare module "flagrate/form" {
    import { Attribute, Property, InsertPosition, FHTMLDivElement, FHTMLInputElement, FHTMLFormElement, FHTMLLabelElement, FHTMLUListElement } from "flagrate/element";
    import { TextInput } from "flagrate/text-input";
    import { TextArea } from "flagrate/text-area";
    import { ComboBox } from "flagrate/combo-box";
    import { Checkbox } from "flagrate/checkbox";
    import { Checkboxes, CheckboxOption as CheckboxesItem } from "flagrate/checkboxes";
    import { Switch } from "flagrate/switch";
    import { Radios, RadioOption as RadiosItem } from "flagrate/radios";
    import { Select, ItemOption as SelectItem } from "flagrate/select";
    export interface Option {
        fields?: FieldOption[];
        /** `id` attribute of container. */
        id?: string;
        /** `class` attribute of container. */
        className?: string;
        /** additional attribute of container. */
        attribute?: Attribute;
        /** style of container. (using flagrate.Element.setStyle) */
        style?: Property;
        /** hide labels. */
        nolabel?: boolean;
        /** vertical label style. */
        vertical?: boolean;
    }
    export interface Field extends FieldOption {
        input?: Input;
        getVal?(): any;
        setVal?(val: any): Field;
        validate?(done?: (result?: boolean) => void): void;
        visible?(): boolean;
        /** field container element */
        readonly container?: FHTMLDivElement;
        /** label element */
        readonly labelElement?: FHTMLLabelElement;
        /** input container element */
        _input?: FHTMLDivElement;
        /** dependency references */
        _refs?: Field[];
        _dependsIsOk?: boolean;
        _hasError?: boolean;
        _hasWarning?: boolean;
        _checkRefs?(): void;
        _inputOnChange?(): void;
    }
    export interface FieldOption {
        key?: string;
        pointer?: string;
        label?: string;
        icon?: string;
        text?: string;
        html?: string;
        element?: HTMLElement;
        input?: InputOption;
        depends?: Depend[];
        /** `id` attribute of container. */
        id?: string;
        /** `class` attribute of container. */
        className?: string;
        /** additional attribute of container. */
        attribute?: Attribute;
        /** style of container. (using flagrate.Element.setStyle) */
        style?: Property;
    }
    export interface Input extends InputOption {
        type?: InputType;
        validators?: (RegExpValidator | ValidatorFunction)[];
        /** input element */
        readonly element?: FHTMLDivElement;
        _result?: FHTMLUListElement;
    }
    export interface InputOption {
        type?: string | InputType;
        val?: any;
        /** default is `false`. */
        isRequired?: boolean;
        min?: number;
        max?: number;
        minLength?: number;
        maxLength?: number;
        validators?: (string | RegExpValidator | ValidatorFunction)[];
        /** if NOT String, use `val.toString()` before resulting. */
        toStr?: boolean;
        /** if String, use `String#trim()` before resulting. */
        trim?: boolean;
        /** if NOT Number, tries to convert to Number. */
        toNumber?: boolean;
        /** alternate result transform/converting function. (only sync) */
        transform?(val?: any): any;
        /** `id` attribute of input element. */
        id?: string;
        /** style of input. (using flagrate.Element.setStyle) */
        style?: Property;
        /** additional attribute of input. */
        attribute?: Attribute;
        placeholder?: string;
        label?: string;
        labelHTML?: string;
        icon?: string;
        items?: (string | number | boolean | CheckboxesItem | SelectItem | RadiosItem)[];
        selectedIndex?: number;
        selectedIndexes?: number[];
        listView?: boolean;
        multiple?: boolean;
        accept?: string;
        acceptTypes?: string[];
    }
    export interface Depend {
        /** unique key for identifying fields. if looking result, must change to use the pointer. */
        key?: string;
        pointer?: string;
        val?: any;
        /** comparison operator */
        op?: "===" | "!==" | ">=" | "<=" | ">" | "<" | "in";
        /** alternate testing function. this disables normal testing. (only sync) */
        tester?(a?: any, b?: any): boolean;
    }
    export interface InputType {
        changeEvents?: string[];
        create(): HTMLElement;
        getVal(): any;
        setVal(val?: any): void;
        enable(): void;
        disable(): void;
    }
    export interface RegExpValidator {
        regexp: RegExp;
        success?: string;
        error?: string;
    }
    export type ValidatorFunction = (input: any, done: (result: boolean | "success" | "warning" | "error", message?: string) => void) => void;
    export class Form {
        private _opt;
        private _fields;
        private _nolabel;
        private _vertical;
        element: FHTMLFormElement;
        static idCounter: number;
        private _id;
        private _renderTimer;
        constructor(_opt?: Option);
        insertTo(element: HTMLElement, pos?: InsertPosition): this;
        on(eventType: string, listener: EventListener, useCapture?: boolean): this;
        off(eventType: string, listener?: EventListener, useCapture?: boolean): this;
        /** Returns a result Object. */
        getResult(): any;
        validate(callback?: (success?: boolean) => void): this;
        enable(): this;
        disable(): this;
        getField(key: string): Field;
        push(field: Field): number;
        push(fields: Field[]): number;
        splice(index: number, howMany?: number, fields?: Field[]): Field[];
        splice(index: number, howMany?: number, field?: Field): Field[];
        removeField(field: Field): Field;
        removeField(fields: Field[]): Field[];
        indexOf(field: Field): number;
        indexOf(keyOfField: string): number;
        private _create();
        private _requestRender();
        private _render();
        private _collectFieldRefs(field);
        private _compareDepend(d);
        private _checkFieldDepends(field);
        private _createField(field);
        static inputValidator: {
            numeric: {
                regexp: RegExp;
            };
            alphanumeric: {
                regexp: RegExp;
            };
        };
        static inputType: {
            text: {
                changeEvents: string[];
                create(): TextInput;
                getVal(): string;
                setVal(value: string): void;
                enable(): void;
                disable(): void;
            };
            password: {
                changeEvents: string[];
                create(): TextInput;
                getVal(): string;
                setVal(value: string): void;
                enable(): void;
                disable(): void;
            };
            textarea: {
                changeEvents: string[];
                create(): TextArea;
                getVal(): string;
                setVal(value: string): void;
                enable(): void;
                disable(): void;
            };
            number: {
                changeEvents: string[];
                create(): TextInput;
                getVal(): number;
                setVal(value: string): void;
                enable(): void;
                disable(): void;
            };
            combobox: {
                changeEvents: string[];
                create(): ComboBox;
                getVal(): string;
                setVal(value: string): void;
                enable(): void;
                disable(): void;
            };
            checkbox: {
                create(): Checkbox;
                getVal(): boolean;
                setVal(value: boolean): void;
                enable(): void;
                disable(): void;
            };
            checkboxes: {
                create(): Checkboxes;
                getVal(): any;
                setVal(values: any): void;
                enable(): void;
                disable(): void;
            };
            "switch": {
                create(): Switch;
                getVal(): boolean;
                setVal(value: boolean): void;
                enable(): void;
                disable(): void;
            };
            radios: {
                create(): Radios;
                getVal(): string;
                setVal(value: string): void;
                enable(): void;
                disable(): void;
            };
            select: {
                create(): Select;
                getVal(): any;
                setVal(val: any): void;
                enable(): void;
                disable(): void;
            };
            file: {
                create(): FHTMLInputElement;
                getVal(): any;
                setVal(file: any): void;
                enable(): void;
                disable(): void;
            };
            files: {
                create(): FHTMLInputElement;
                getVal(): any;
                setVal(files: any): void;
                enable(): void;
                disable(): void;
            };
        };
    }
    export function createForm(option?: Option): Form;
}
declare module "flagrate" {
    import * as util from "flagrate/util";
    import * as element from "flagrate/element";
    import * as button from "flagrate/button";
    import * as buttons from "flagrate/buttons";
    import * as menu from "flagrate/menu";
    import * as pulldown from "flagrate/pulldown";
    import * as textInput from "flagrate/text-input";
    import * as tokenizer from "flagrate/tokenizer";
    import * as textArea from "flagrate/text-area";
    import * as comboBox from "flagrate/combo-box";
    import * as select from "flagrate/select";
    import * as contextMenu from "flagrate/context-menu";
    import * as toolbar from "flagrate/toolbar";
    import * as searchBox from "flagrate/search-box";
    import * as checkbox from "flagrate/checkbox";
    import * as checkboxes from "flagrate/checkboxes";
    import * as radio from "flagrate/radio";
    import * as radios from "flagrate/radios";
    import * as sw from "flagrate/switch";
    import * as progress from "flagrate/progress";
    import * as slider from "flagrate/slider";
    import * as tab from "flagrate/tab";
    import * as popover from "flagrate/popover";
    import * as tutorial from "flagrate/tutorial";
    import * as notify from "flagrate/notify";
    import * as modal from "flagrate/modal";
    import * as grid from "flagrate/grid";
    import * as form from "flagrate/form";
    export namespace Flagrate {
        const identity: typeof util.identity;
        const extendObject: typeof util.extendObject;
        const emptyFunction: typeof util.emptyFunction;
        const jsonPointer: typeof util.jsonPointer;
        const Element: element.Class;
        const createElement: element.createElement;
        const Button: button.Class;
        const createButton: typeof button.createButton;
        const Buttons: buttons.Class;
        const createButtons: typeof buttons.createButtons;
        const Menu: menu.Class;
        const createMenu: typeof menu.createMenu;
        const Pulldown: pulldown.Class;
        const createPulldown: typeof pulldown.createPulldown;
        const TextInput: textInput.Class;
        const createTextInput: typeof textInput.createTextInput;
        const Tokenizer: tokenizer.Class;
        const createTokenizer: typeof tokenizer.createTokenizer;
        const TextArea: textArea.Class;
        const createTextArea: typeof textArea.createTextArea;
        const ComboBox: comboBox.Class;
        const createComboBox: typeof comboBox.createComboBox;
        const Select: select.Class;
        const createSelect: typeof select.createSelect;
        const ContextMenu: typeof contextMenu.ContextMenu;
        const createContextMenu: typeof contextMenu.createContextMenu;
        const Toolbar: toolbar.Class;
        const createToolbar: typeof toolbar.createToolbar;
        const SearchBox: searchBox.Class;
        const createSearchBox: typeof searchBox.createSearchBox;
        const Checkbox: checkbox.Class;
        const createCheckbox: typeof checkbox.createCheckbox;
        const Checkboxes: checkboxes.Class;
        const createCheckboxes: typeof checkboxes.createCheckboxes;
        const Radio: radio.Class;
        const createRadio: typeof radio.createRadio;
        const Radios: radios.Class;
        const createRadios: typeof radios.createRadios;
        const Switch: sw.Class;
        const createSwitch: typeof sw.createSwitch;
        const Progress: progress.Class;
        const createProgress: typeof progress.createProgress;
        const Slider: slider.Class;
        const createSlider: typeof slider.createSlider;
        const Tab: tab.Class;
        const createTab: typeof tab.createTab;
        const Popover: typeof popover.Popover;
        const createPopover: typeof popover.createPopover;
        const Tutorial: typeof tutorial.Tutorial;
        const createTutorial: typeof tutorial.createTutorial;
        const Notify: typeof notify.Notify;
        const createNotify: typeof notify.createNotify;
        const Modal: typeof modal.Modal;
        const createModal: typeof modal.createModal;
        const Grid: typeof grid.Grid;
        const createGrid: typeof grid.createGrid;
        const Form: typeof form.Form;
        const createForm: typeof form.createForm;
    }
    global  {
        interface Window {
            flagrate: typeof Flagrate;
        }
    }
    export default Flagrate;
}
