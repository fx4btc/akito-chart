import { Attribute, Property, InsertPosition, FHTMLDivElement, FHTMLInputElement, FHTMLFormElement, FHTMLLabelElement, FHTMLUListElement } from "./element";
import { TextInput } from "./text-input";
import { TextArea } from "./text-area";
import { ComboBox } from "./combo-box";
import { Checkbox } from "./checkbox";
import { Checkboxes, CheckboxOption as CheckboxesItem } from "./checkboxes";
import { Switch } from "./switch";
import { Radios, RadioOption as RadiosItem } from "./radios";
import { Select, ItemOption as SelectItem } from "./select";
export interface Option {
    fields?: FieldOption[];
    /** `id` attribute of container. */
    id?: string;
    /** `class` attribute of container. */
    className?: string;
    /** additional attribute of container. */
    attribute?: Attribute;
    /** style of container. (using flagrate.Element.setStyle) */
    style?: Property;
    /** hide labels. */
    nolabel?: boolean;
    /** vertical label style. */
    vertical?: boolean;
}
export interface Field extends FieldOption {
    input?: Input;
    getVal?(): any;
    setVal?(val: any): Field;
    validate?(done?: (result?: boolean) => void): void;
    visible?(): boolean;
    /** field container element */
    readonly container?: FHTMLDivElement;
    /** label element */
    readonly labelElement?: FHTMLLabelElement;
    /** input container element */
    _input?: FHTMLDivElement;
    /** dependency references */
    _refs?: Field[];
    _dependsIsOk?: boolean;
    _hasError?: boolean;
    _hasWarning?: boolean;
    _checkRefs?(): void;
    _inputOnChange?(): void;
}
export interface FieldOption {
    key?: string;
    pointer?: string;
    label?: string;
    icon?: string;
    text?: string;
    html?: string;
    element?: HTMLElement;
    input?: InputOption;
    depends?: Depend[];
    /** `id` attribute of container. */
    id?: string;
    /** `class` attribute of container. */
    className?: string;
    /** additional attribute of container. */
    attribute?: Attribute;
    /** style of container. (using flagrate.Element.setStyle) */
    style?: Property;
}
export interface Input extends InputOption {
    type?: InputType;
    validators?: (RegExpValidator | ValidatorFunction)[];
    /** input element */
    readonly element?: FHTMLDivElement;
    _result?: FHTMLUListElement;
}
export interface InputOption {
    type?: string | InputType;
    val?: any;
    /** default is `false`. */
    isRequired?: boolean;
    min?: number;
    max?: number;
    minLength?: number;
    maxLength?: number;
    validators?: (string | RegExpValidator | ValidatorFunction)[];
    /** if NOT String, use `val.toString()` before resulting. */
    toStr?: boolean;
    /** if String, use `String#trim()` before resulting. */
    trim?: boolean;
    /** if NOT Number, tries to convert to Number. */
    toNumber?: boolean;
    /** alternate result transform/converting function. (only sync) */
    transform?(val?: any): any;
    /** `id` attribute of input element. */
    id?: string;
    /** style of input. (using flagrate.Element.setStyle) */
    style?: Property;
    /** additional attribute of input. */
    attribute?: Attribute;
    placeholder?: string;
    label?: string;
    labelHTML?: string;
    icon?: string;
    items?: (string | number | boolean | CheckboxesItem | SelectItem | RadiosItem)[];
    selectedIndex?: number;
    selectedIndexes?: number[];
    listView?: boolean;
    multiple?: boolean;
    accept?: string;
    acceptTypes?: string[];
}
export interface Depend {
    /** unique key for identifying fields. if looking result, must change to use the pointer. */
    key?: string;
    pointer?: string;
    val?: any;
    /** comparison operator */
    op?: "===" | "!==" | ">=" | "<=" | ">" | "<" | "in";
    /** alternate testing function. this disables normal testing. (only sync) */
    tester?(a?: any, b?: any): boolean;
}
export interface InputType {
    changeEvents?: string[];
    create(): HTMLElement;
    getVal(): any;
    setVal(val?: any): void;
    enable(): void;
    disable(): void;
}
export interface RegExpValidator {
    regexp: RegExp;
    success?: string;
    error?: string;
}
export declare type ValidatorFunction = (input: any, done: (result: boolean | "success" | "warning" | "error", message?: string) => void) => void;
export declare class Form {
    private _opt;
    private _fields;
    private _nolabel;
    private _vertical;
    element: FHTMLFormElement;
    static idCounter: number;
    private _id;
    private _renderTimer;
    constructor(_opt?: Option);
    insertTo(element: HTMLElement, pos?: InsertPosition): this;
    on(eventType: string, listener: EventListener, useCapture?: boolean): this;
    off(eventType: string, listener?: EventListener, useCapture?: boolean): this;
    /** Returns a result Object. */
    getResult(): any;
    validate(callback?: (success?: boolean) => void): this;
    enable(): this;
    disable(): this;
    getField(key: string): Field;
    push(field: Field): number;
    push(fields: Field[]): number;
    splice(index: number, howMany?: number, fields?: Field[]): Field[];
    splice(index: number, howMany?: number, field?: Field): Field[];
    removeField(field: Field): Field;
    removeField(fields: Field[]): Field[];
    indexOf(field: Field): number;
    indexOf(keyOfField: string): number;
    private _create();
    private _requestRender();
    private _render();
    private _collectFieldRefs(field);
    private _compareDepend(d);
    private _checkFieldDepends(field);
    private _createField(field);
    static inputValidator: {
        numeric: {
            regexp: RegExp;
        };
        alphanumeric: {
            regexp: RegExp;
        };
    };
    static inputType: {
        text: {
            changeEvents: string[];
            create(): TextInput;
            getVal(): string;
            setVal(value: string): void;
            enable(): void;
            disable(): void;
        };
        password: {
            changeEvents: string[];
            create(): TextInput;
            getVal(): string;
            setVal(value: string): void;
            enable(): void;
            disable(): void;
        };
        textarea: {
            changeEvents: string[];
            create(): TextArea;
            getVal(): string;
            setVal(value: string): void;
            enable(): void;
            disable(): void;
        };
        number: {
            changeEvents: string[];
            create(): TextInput;
            getVal(): number;
            setVal(value: string): void;
            enable(): void;
            disable(): void;
        };
        combobox: {
            changeEvents: string[];
            create(): ComboBox;
            getVal(): string;
            setVal(value: string): void;
            enable(): void;
            disable(): void;
        };
        checkbox: {
            create(): Checkbox;
            getVal(): boolean;
            setVal(value: boolean): void;
            enable(): void;
            disable(): void;
        };
        checkboxes: {
            create(): Checkboxes;
            getVal(): any;
            setVal(values: any): void;
            enable(): void;
            disable(): void;
        };
        "switch": {
            create(): Switch;
            getVal(): boolean;
            setVal(value: boolean): void;
            enable(): void;
            disable(): void;
        };
        radios: {
            create(): Radios;
            getVal(): string;
            setVal(value: string): void;
            enable(): void;
            disable(): void;
        };
        select: {
            create(): Select;
            getVal(): any;
            setVal(val: any): void;
            enable(): void;
            disable(): void;
        };
        file: {
            create(): FHTMLInputElement;
            getVal(): any;
            setVal(file: any): void;
            enable(): void;
            disable(): void;
        };
        files: {
            create(): FHTMLInputElement;
            getVal(): any;
            setVal(files: any): void;
            enable(): void;
            disable(): void;
        };
    };
}
export declare function createForm(option?: Option): Form;
